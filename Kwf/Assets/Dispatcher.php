<?php
class Kwf_Assets_Dispatcher
{
    public static function getInstance()
    {
        static $i;
        if (!isset($i)) {
            $cls = Kwf_Config::getValue('assets.dispatcherClass');
            $i = new $cls();
        }
        return $i;
    }

    public function dispatch($url)
    {
        if (substr($url, 0, 21)=='/assets/dependencies/') {
            $out = $this->getOutputForUrl($url, Kwf_Media_Output::getEncoding());
            Kwf_Media_Output::output($out);
        }
    }

    public function allowSourceAccess()
    {
        $ok = false;
        foreach (Kwf_Config::getValueArray('debug.assets.sourceAccessIp') as $i) {
            if (!$i) continue;
            if (substr($i, -1)=='*') {
                $i = substr($i, 0, -1);
                if (substr($_SERVER['REMOTE_ADDR'], 0, strlen($i)) == $i) {
                    $ok = true;
                }
            } else {
                if ($_SERVER['REMOTE_ADDR'] == $i) $ok = true;
            }
        }
        return $ok;
    }

    /**
     *
     * @param string Url as generated by Kwf_Assets_Package::getPackageUrls
     * @param string Kwf_Media_Output::ENCODING_*
     */
    public function getOutputForUrl($url, $encoding)
    {
        if (substr($url, 0, 21) != '/assets/dependencies/') throw new Kwf_Exception("invalid url: '$url'");
        $url = substr($url, 21);
        if (strpos($url, '?') !== false) {
            $url = substr($url, 0, strpos($url, '?'));
        }

        if (substr($url, -4) == '.map' && !$this->allowSourceAccess()) {
            throw new Kwf_Exception_AccessDenied();
        }

        if ($encoding != 'none') {
            //own cache for encoded contents, not using Kwf_Assets_Cache as we don't need to in two-level cache
            $cacheId = 'as_'.$this->_getCacheIdByUrl($url).'_'.$encoding;
            $ret = Kwf_Cache_SimpleStatic::fetch($cacheId);

            if ($ret === false) {
                $ret = $this->_getOutputForUrlNoEncoding($url);
                $ret['contents'] = Kwf_Media_Output::encode($ret['contents'], $encoding);
                $ret['encoding'] = $encoding;
                Kwf_Cache_SimpleStatic::add($cacheId, $ret);
            }
            return $ret;
        } else {
            return $this->_getOutputForUrlNoEncoding($url);
        }
    }

    protected final function _getCacheIdByUrl($url)
    {
        return str_replace(array(':', '/', '.', ','), '_', $url);
    }

    public function getCacheIdByPackage($package, $ext, $language)
    {
        $ret = $package->getPackageUrl($ext, $language);
        if (Kwf_Setup::getBaseUrl()) $ret = substr($ret, strlen(Kwf_Setup::getBaseUrl()));
        if (substr($ret, 0, 21) != '/assets/dependencies/') throw new Kwf_Exception("invalid url: '$url'");
        $ret = substr($ret, 21);
        if (strpos($ret, '?') !== false) {
            $ret = substr($ret, 0, strpos($ret, '?'));
        }
        return $this->_getCacheIdByUrl($ret);
    }

    protected function _getOutputForUrlNoEncoding($url)
    {
        $cacheId = $this->_getCacheIdByUrl($url);
        $ret = Kwf_Assets_Cache::getInstance()->load($cacheId);

        if ($ret === false) {
            $ret = Kwf_Assets_BuildCache::getInstance()->load($cacheId);

            if ($ret === false || $ret === 'outdated') {
                if ($ret === 'outdated' && Kwf_Config::getValue('assets.lazyBuild') == 'outdated') {
                    Kwf_Assets_BuildCache::getInstance()->building = true;
                }
                $ret = $this->_buildOutputForUrl($url);
                Kwf_Assets_BuildCache::getInstance()->building = false;

                if (substr($url, -4) != '.map') {
                    //save generated caches for clear-cache-watcher
                    $extension = substr($url, -(strlen($url)-strrpos($url, '/')-1));
                    $fileName = 'cache/assets/output-cache-ids-'.$extension;
                    if (!file_exists($fileName) || strpos(file_get_contents($fileName), $cacheId."\n") === false) {
                        file_put_contents($fileName, $cacheId."\n", FILE_APPEND);
                    }
                }
            }

            if (Kwf_Setup::getBaseUrl()) {
                if (substr($url, -4) == '.map') {
                    $contentUrl = substr($url, 0, -4);
                    $extension = substr($contentUrl, strrpos($contentUrl, '/')+1);
                    $replacements = $this->_getBaseUrlReplacements($extension, $ret['contents']);
                    $map = new Kwf_SourceMaps_SourceMap($ret['contents'], '');
                    foreach ($replacements as $i) {
                        $map->stringReplace($i['search'], $i['replace']);
                    }
                    $map = $map->getMapContentsData(false);
                    foreach ($map->sources as $k=>$i) {
                        $map->sources[$k] = Kwf_Setup::getBaseUrl().$i;
                    }
                    $ret['contents'] = json_encode($map);
                } else {
                    $extension = substr($url, strrpos($url, '/')+1);
                    $replacements = $this->_getBaseUrlReplacements($extension, $ret['contents']);
                    foreach ($replacements as $i) {
                        $ret['contents'] = str_replace($i['search'], $i['replace'], $ret['contents']);
                    }
                }
            }
            Kwf_Assets_Cache::getInstance()->save($ret, $cacheId);
        }
        return $ret;
    }

    private function _buildOutputForUrl($url)
    {
        class_exists('Kwf_Trl'); //required because setup doesn't load Trl.php before dispatching assets
        $param = explode('/', $url);
        if (count($param) != 4) throw new Kwf_Exception_NotFound();
        $dependencyClass = $param[0];
        $dependencyParams = $param[1];
        $language = $param[2];
        $extension = $param[3];
        if (!class_exists($dependencyClass)) {
            throw new Kwf_Exception_NotFound();
        }
        if (!is_instance_of($dependencyClass, 'Kwf_Assets_Interface_UrlResolvable')) {
            throw new Kwf_Exception_NotFound();
        }
        $package = call_user_func(array($dependencyClass, 'fromUrlParameter'), $dependencyClass, $dependencyParams);
        if (!$package instanceof Kwf_Assets_Package) {
            throw new Kwf_Exception_NotFound();
        }

        return $package->getUrlContents($extension, $language);
    }

    private function _getBaseUrlReplacements($extension, $contents)
    {
        $baseUrl = Kwf_Setup::getBaseUrl();
        if (!$baseUrl) return array();
        $ret = array();
        if (preg_match_all('#url\\((\s*[\'"]?)/assets/#', $contents, $m)) {
            foreach ($m[0] as $k=>$i) {
                $ret[] = array(
                    'search' => $i,
                    'replace' => 'url('.$m[1][$k].''.$baseUrl.'/assets/'
                );
            }
        }
        if ($extension == 'js' || $extension == 'defer.js') {
            if (preg_match_all('#([\'"])/(kwf|vkwf|admin|assets|api)/#', $contents, $m)) {
                foreach ($m[0] as $k=>$i) {
                    $ret[] = array(
                        'search' => $i,
                        'replace' => $m[1][$k].$baseUrl.'/'.$m[2][$k].'/'
                    );
                }
            }
        }
        return $ret;
    }

    /**
     * Returns a timestamp that can be used as assets version
     *
     * will be reset everytime assets are built
     */
    public function getAssetsVersion()
    {
        return  Kwf_Assets_BuildCache::getInstance()->load('assetsVersion');
    }
}
